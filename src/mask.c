/* Filter mask routines.
 *
 * Copyright (c) 2011 Michael Abbott, Diamond Light Source Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Contact:
 *      Dr. Michael Abbott,
 *      Diamond Light Source Ltd,
 *      Diamond House,
 *      Chilton,
 *      Didcot,
 *      Oxfordshire,
 *      OX11 0DE
 *      michael.abbott@diamond.ac.uk
 */

/* The filter mask is used to specify a list of PVs.  The syntax of a filter
 * mask can be written as:
 *
 *      mask = id [ "-" id ] [ "," mask]
 *
 * Here each id identifies a particular BPM and must be a number in the range
 * 0 to 255 and id1-id2 identifies an inclusive range of BPMs.
 */


#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdarg.h>
#include <unistd.h>
#include <string.h>

#include "error.h"
#include "fa_sniffer.h"
#include "parse.h"

#include "mask.h"


#define WRITE_BUFFER_SIZE       (1 << 16)


unsigned int count_mask_bits(const struct filter_mask *mask)
{
    unsigned int count = 0;
    for (int bit = 0; bit < FA_ENTRY_COUNT; bit ++)
        if (test_mask_bit(mask, bit))
            count ++;
    return count;
}


int format_raw_mask(const struct filter_mask *mask, char *buffer)
{
    for (int i = sizeof(mask->mask); i > 0; i --)
        buffer += sprintf(buffer, "%02X",
            ((unsigned char *) mask->mask)[i - 1]);
    return 2 * sizeof(mask->mask);
}



static bool parse_id(const char **string, int *id)
{
    return
        parse_int(string, id)  &&
        TEST_OK_(0 <= *id  &&  *id < FA_ENTRY_COUNT, "id %d out of range", *id);
}


/* Parses a mask in the form generated by format_mask(), namely a sequence of 64
 * hex digits. */
static bool parse_raw_mask(const char **string, struct filter_mask *mask)
{
    int count = FA_ENTRY_COUNT / 4;                 // 4 bits per nibble
    for (unsigned int i = count; i > 0; )
    {
        i -= 1;
        unsigned char ch = *(*string)++;
        unsigned int nibble;
        if ('0' <= ch  &&  ch <= '9')
            nibble = ch - '0';
        else if ('A' <= ch  &&  ch <= 'F')
            nibble = ch - 'A' + 10;
        else
            return FAIL_("Unexpected character in mask");
        mask->mask[i / 8] |= nibble << (4 * (i % 8));   // 8 nibbles per word
    }
    return true;
}


bool parse_mask(const char **string, struct filter_mask *mask)
{
    memset(mask->mask, 0, sizeof(mask->mask));

    if (read_char(string, 'R'))
        return parse_raw_mask(string, mask);
    else
    {
        bool ok = true;
        do {
            int id;
            ok = parse_id(string, &id);
            if (ok)
            {
                int end_id = id;
                if (read_char(string, '-'))
                    ok =
                        parse_id(string, &end_id)  &&
                        TEST_OK_(id <= end_id,
                            "Range %d-%d is empty", id, end_id);
                for (int i = id; ok  &&  i <= end_id; i ++)
                    set_mask_bit(mask, i);
            }
        } while (ok  &&  read_char(string, ','));

        return ok;
    }
}


/* Support functions for format_mask() to help safely write values into a
 * string. */
static bool write_string(char **string, size_t *length, const char *value)
{
    size_t value_len = strlen(value);
    if (TEST_OK_(value_len + 1 < *length, "Mask too long to format"))
    {
        memcpy(*string, value, value_len + 1);
        *string += value_len;
        *length -= value_len;
        return true;
    }
    else
        return false;
}

static bool write_int(char **string, size_t *length, int value)
{
    char buffer[24];
    sprintf(buffer, "%d", value);
    return write_string(string, length, buffer);
}

static bool write_range(
    char **string, size_t *length, int start, int end, bool first)
{
    return
        IF_(!first, write_string(string, length, ","))  &&
        write_int(string, length, start)  &&
        IF_(end > start,
            write_string(string, length, "-")  &&
            write_int(string, length, end));
}

bool format_mask(struct filter_mask *mask, char *string, size_t length)
{
    bool ok = true;
    bool in_range = false;
    bool first = true;
    int range_start = 0;
    *string = '\0';
    for (int id = 0; ok  &&  id < FA_ENTRY_COUNT; id ++)
    {
        bool set = test_mask_bit(mask, id);
        if (set  &&  !in_range)
        {
            /* Starting a new range of values.  Write the first number. */
            in_range = true;
            range_start = id;
        }
        else if (!set  &&  in_range)
        {
            /* End of range, now write it out. */
            ok = write_range(&string, &length, range_start, id - 1, first);
            in_range = false;
            first = false;
        }
    }
    if (ok  &&  in_range)
        ok = write_range(
            &string, &length, range_start, FA_ENTRY_COUNT - 1, first);
    return ok;
}


int copy_frame(void *to, const void *from, const struct filter_mask *mask)
{
    const int32_t *from_p = from;
    int32_t *to_p = to;
    int copied = 0;
    for (size_t i = 0; i < sizeof(mask->mask) / 4; i ++)
    {
        uint32_t m = mask->mask[i];
        for (unsigned int j = 0; j < 32; j ++)
        {
            if ((m >> j) & 1)
            {
                *to_p++ = from_p[0];
                *to_p++ = from_p[1];
                copied += 8;
            }
            from_p += 2;
        }
    }
    return copied;
}


bool write_frames(
    int file, const struct filter_mask *mask, const void *frame, int count)
{
    int out_frame_size = count_mask_bits(mask) * FA_ENTRY_SIZE;
    while (count > 0)
    {
        char buffer[WRITE_BUFFER_SIZE];
        size_t buffered = 0;
        while (count > 0  &&  buffered + out_frame_size <= WRITE_BUFFER_SIZE)
        {
            copy_frame(buffer + buffered, frame, mask);
            frame = frame + FA_FRAME_SIZE;
            buffered += out_frame_size;
            count -= 1;
        }

        size_t written = 0;
        while (buffered > 0)
        {
            size_t wr;
            if (!TEST_IO_(wr = write(file, buffer + written, buffered),
                    "Unable to write frame"))
                return false;
            written += wr;
            buffered -= wr;
        }
    }
    return true;
}
