/* Filter mask routines.
 *
 * Copyright (c) 2011 Michael Abbott, Diamond Light Source Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Contact:
 *      Dr. Michael Abbott,
 *      Diamond Light Source Ltd,
 *      Diamond House,
 *      Chilton,
 *      Didcot,
 *      Oxfordshire,
 *      OX11 0DE
 *      michael.abbott@diamond.ac.uk
 */

/* The filter mask is used to specify a list of PVs.  The syntax of a filter
 * mask can be written as:
 *
 *      mask = id [ "-" id ] [ "," mask]
 *
 * Here each id identifies a particular BPM and must be a number in the range
 * 0 to 255 and id1-id2 identifies an inclusive range of BPMs.
 */


#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdarg.h>
#include <unistd.h>
#include <string.h>

#include "error.h"
#include "fa_sniffer.h"
#include "parse.h"

#include "mask.h"


unsigned int count_mask_bits(
    const struct filter_mask *mask, unsigned int fa_entry_count)
{
    unsigned int count = 0;
    for (unsigned int bit = 0; bit < fa_entry_count; bit ++)
        if (test_mask_bit(mask, bit))
            count ++;
    return count;
}


unsigned int format_raw_mask(
    const struct filter_mask *mask, unsigned int fa_entry_count, char *buffer)
{
    for (unsigned int i = fa_entry_count / 8; i > 0; i --)
        buffer += sprintf(buffer, "%02X", mask->mask[i - 1]);
    return 4 * fa_entry_count;
}



static bool parse_id(
    const char **string, unsigned int fa_entry_count, unsigned int *id)
{
    return
        parse_uint(string, id)  &&
        TEST_OK_(*id < fa_entry_count, "id %u out of range", *id);
}


/* Parses a mask in the form generated by format_raw_mask(), namely a sequence
 * of hex digits. */
static bool parse_raw_mask(
    const char **string, unsigned int fa_entry_count, struct filter_mask *mask)
{
    unsigned int count = fa_entry_count / 4;        // 4 bits per nibble
    for (unsigned int i = count; i > 0; )
    {
        i -= 1;
        unsigned int ch = **string;
        unsigned int nibble;
        if ('0' <= ch  &&  ch <= '9')
            nibble = ch - '0';
        else if ('A' <= ch  &&  ch <= 'F')
            nibble = ch - 'A' + 10;
        else if (ch == '\0')
            return FAIL_("Mask too short");
        else
            return FAIL_("Unexpected character in mask");

        *string += 1;
        // 2 nibbles per byte
        mask->mask[i / 2] |= (uint8_t) (nibble << (4 * (i % 2)));
    }
    return
        TEST_OK_(count_mask_bits(mask, fa_entry_count) > 0,
            "Empty request mask");
}


bool parse_mask(
    const char **string, unsigned int fa_entry_count, struct filter_mask *mask)
{
    memset(mask->mask, 0, sizeof(mask->mask));

    if (read_char(string, 'R'))
        return parse_raw_mask(string, fa_entry_count, mask);
    else
    {
        bool ok = true;
        do {
            unsigned int id;
            ok = parse_id(string, fa_entry_count, &id);
            if (ok)
            {
                unsigned int end_id = id;
                if (read_char(string, '-'))
                    ok =
                        parse_id(string, fa_entry_count, &end_id)  &&
                        TEST_OK_(id <= end_id,
                            "Range %d-%d is empty", id, end_id);
                for (unsigned int i = id; ok  &&  i <= end_id; i ++)
                    set_mask_bit(mask, i);
            }
        } while (ok  &&  read_char(string, ','));

        return ok;
    }
}


/* Support functions for format_mask() to help safely write values into a
 * string. */
static bool write_string(char **string, size_t *length, const char *value)
{
    size_t value_len = strlen(value);
    if (value_len + 1 < *length)
    {
        memcpy(*string, value, value_len + 1);
        *string += value_len;
        *length -= value_len;
        return true;
    }
    else
        return false;
}

static bool write_uint(char **string, size_t *length, unsigned int value)
{
    char buffer[24];
    sprintf(buffer, "%d", value);
    return write_string(string, length, buffer);
}

static bool write_range(
    char **string, size_t *length,
    unsigned int start, unsigned int end, bool first)
{
    return
        IF_(!first, write_string(string, length, ","))  &&
        write_uint(string, length, start)  &&
        IF_(end > start,
            write_string(string, length, "-")  &&
            write_uint(string, length, end));
}

bool format_readable_mask(
    const struct filter_mask *mask, unsigned int fa_entry_count,
    char *string, size_t length)
{
    bool ok = true;
    bool in_range = false;
    bool first = true;
    unsigned int range_start = 0;
    *string = '\0';
    for (unsigned int id = 0; ok  &&  id < fa_entry_count; id ++)
    {
        bool set = test_mask_bit(mask, id);
        if (set  &&  !in_range)
        {
            /* Starting a new range of values.  Write the first number. */
            in_range = true;
            range_start = id;
        }
        else if (!set  &&  in_range)
        {
            /* End of range, now write it out. */
            ok = write_range(&string, &length, range_start, id - 1, first);
            in_range = false;
            first = false;
        }
    }
    if (ok  &&  in_range)
        ok = write_range(
            &string, &length, range_start, fa_entry_count - 1, first);
    return ok;
}


unsigned int format_mask(
    const struct filter_mask *mask, unsigned int fa_entry_count, char *buffer)
{
    if (format_readable_mask(mask, fa_entry_count, buffer, fa_entry_count / 4))
        return (unsigned int) strlen(buffer);
    else
    {
        buffer[0] = 'R';
        return format_raw_mask(mask, fa_entry_count, buffer + 1);
    }
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* Support for list of FA ids. */

struct fa_id_list {
    const char *description;
    const char *x_name;
    const char *y_name;
};

static struct fa_id_list *fa_id_list;
static uint32_t id_list_length;


/* Parses a white-space delimited word if present, returns false if nothing
 * found and assigns NULL to result. */
static bool maybe_parse_word(const char **string, const char **result)
{
    const char *start = *string;
    const char *end = strchrnul(start, ' ');
    if (end == start)
    {
        *result = NULL;
        return false;
    }
    else
    {
        size_t length = (size_t) (end - start);
        char *word = malloc(length + 1);
        memcpy(word, start, length);
        word[length] = '\0';
        *string = end;
        *result = word;
        return true;
    }
}

/* Each line in the file consists of up to four whitespace separated fields:
 *  id [description] [x_name] [y_name]
 */
static bool parse_fa_id_line(const char **line, bool seen[])
{
    int id;
    bool ok =
        parse_int(line, &id)  &&
        TEST_OK_(0 <= id  &&  (uint32_t) id < id_list_length,
            "FA id %d out of range", id)  &&
        TEST_OK_(!seen[id], "FA id %u repeated", id);
    if (ok)
    {
        seen[id] = true;
        struct fa_id_list *entry = &fa_id_list[id];
        IGNORE(
            skip_whitespace(line)  &&
            maybe_parse_word(line, &entry->description)  &&
            skip_whitespace(line)  &&
            maybe_parse_word(line, &entry->x_name)  &&
            skip_whitespace(line)  &&
            maybe_parse_word(line, &entry->y_name));
    }
    return ok;
}

static bool load_fa_ids_file(const char *filename)
{
    FILE *input;
    bool ok = TEST_NULL_(input = fopen(filename, "r"),
        "Unable to open IDs file \"%s\"", filename);
    if (ok)
    {
        bool seen[id_list_length];
        memset(seen, 0, id_list_length * sizeof(bool));

        char line[1024];
        while (ok  &&  fgets(line, sizeof(line), input))
        {
            /* Check the line hasn't been truncated.  This also complains if the
             * file ends without a newline, but that's too bad. */
            char *eol;
            ok =
                TEST_NULL_(eol = strchr(line, '\n'),
                    "Line truncated or missing newline at end of file")  &&
                DO_(*eol = '\0')  &&
                /* Fixed format: blank lines or lines beginning with # are
                 * ignored, all other lines must be a number followed by
                 * optional whitespace followed by an optional description. */
                IF_(line[0] != '\0'  &&  line[0] != '#',
                    DO_PARSE("FA ID file", parse_fa_id_line, line, seen));
        }
        fclose(input);
    }
    return ok;
}

bool load_fa_ids(const char *filename, uint32_t fa_entry_count)
{
    fa_id_list = calloc(fa_entry_count, sizeof(struct fa_id_list));
    id_list_length = fa_entry_count;
    return IF_(filename, load_fa_ids_file(filename));
}


bool write_fa_ids(int output, const struct filter_mask *archive_mask)
{
    bool ok = true;
    for (uint32_t id = 0; ok  &&  id < id_list_length; id ++)
    {
        struct fa_id_list *entry = &fa_id_list[id];
        bool archived = test_mask_bit(archive_mask, id);
        if (archived  ||  entry->description)
        {
            char *buffer = NULL;
            ok =
                TEST_IO(asprintf(&buffer, "%c%u %s %s %s\n",
                    archived ? '*' : ' ', id,
                    entry->x_name ?: "X", entry->y_name ?: "Y",
                    entry->description ?: ""))  &&
                TEST_write_(
                    output, buffer, strlen(buffer), "Unable to write response");
            free(buffer);
        }
    }
    return ok;
}
