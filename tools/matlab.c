/* Support for writing a matlab header on capture FA data. */

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>

#include "sniffer.h"
#include "mask.h"
#include "error.h"

#include "matlab.h"


/* The delta (in days) between the Unix and matlab epochs, generated by running
 *  datenum(1970, 1, 1)
 * in matlab. */
#define MATLAB_EPOCH    719529
#define SECS_PER_DAY    (24 * 60 * 60)


/* The matlab format symbol definitions we use. */
#define miINT8          1
#define miUINT8         2
#define miINT16         3
#define miUINT16        4
#define miINT32         5
#define miUINT32        6
#define miDOUBLE        9

#define miMATRIX        14

#define mxDOUBLE_CLASS  6
#define mxINT32_CLASS   12


/* Sizes of matlab formats, dynamically looked up. */
static struct { int format; size_t size; } format_sizes[] = {
    { miINT8,   sizeof(int8_t) },
    { miUINT8,  sizeof(uint8_t) },
    { miINT16,  sizeof(int16_t) },
    { miUINT16, sizeof(uint16_t) },
    { miINT32,  sizeof(int32_t) },
    { miUINT32, sizeof(uint32_t) },
    { miDOUBLE, sizeof(double) },
};

static size_t lookup_size(int format)
{
    for (size_t i = 0; i < ARRAY_SIZE(format_sizes); i ++)
        if (format_sizes[i].format == format)
            return format_sizes[i].size;
    ASSERT_OK(false);
}


static int compute_mask_ids(uint8_t *array, filter_mask_t mask)
{
    int count = 0;
    for (int bit = 0; bit < 256; bit ++)
        if (test_mask_bit(mask, bit))
        {
            *array++ = bit;
            count += 1;
        }
    return count;
}


static void write_matlab_string(int32_t **hh, const char *string)
{
    int32_t *h = *hh;
    int l = strlen(string);
    *h++ = miINT8;      *h++ = l;
    memcpy(h, string, l);
    *hh = h + 2 * ((l + 7) / 8);
}


/* Returns the number of bytes of padding required after data_length bytes of
 * following data to ensure that the entire matrix is padded to 8 bytes. */
static int write_matrix_header(
    int32_t **hh, const char *name, int data_type,
    bool *squeeze, int data_length, int dimensions, ...)
{
    va_list dims;
    va_start(dims, dimensions);

    int32_t *h = *hh;
    *h++ = miMATRIX;
    int32_t *l = h++;   // total length will be written here.
    // Matrix flags: consists of two uint32 words encoding the class.
    *h++ = miUINT32;    *h++ = 8;
    *h++ = mxDOUBLE_CLASS;
    *h++ = 0;

    // Matrix dimensions: one int32 for each dimension
    *h++ = miINT32;
    int32_t *dim_size = h++;    // Size of dimensions to be written here
    int squeezed_dims = 0;
    for (int i = 0; i < dimensions; i ++)
    {
        int size = va_arg(dims, int32_t);
        if (size == 1  &&  squeeze != NULL  &&  squeeze[i])
            /* Squeeze this dimension out by ignoring it altogether. */
            ;
        else
        {
            *h++ = size;
            squeezed_dims += 1;
        }
    }
    *dim_size = squeezed_dims * sizeof(int32_t);
    h += squeezed_dims & 1;    // Padding if required

    // Element name
    write_matlab_string(&h, name);

    // Data header: data follows directly after.
    int padding = (8 - data_length) & 7;
    *h++ = data_type;   *h++ = data_length;
    *l = data_length + (h - l - 1) * sizeof(int32_t) + padding;

    *hh = h;
    return padding;
}


/* Advances pointer by length together with the precomputed padding. */
static void pad(int32_t **hh, int length, int padding)
{
    *hh = (int32_t *)((char *)*hh + length + padding);
}


static void write_matlab_value(
    int32_t **hh, const char *name, int data_type, void *data)
{
    size_t data_size = lookup_size(data_type);
    int padding = write_matrix_header(
        hh, name, data_type, NULL, data_size, 1, 1);
    memcpy(*hh, data, data_size);
    pad(hh, data_size, padding);
}


static void write_matlab_vector(
    int32_t **hh, const char *name, int data_type,
    void *data, int vector_length)
{
    int data_length = lookup_size(data_type) * vector_length;
    int padding = write_matrix_header(
        hh, name, data_type, NULL, data_length, 2, 1, vector_length);
    memcpy(*hh, data, data_length);
    pad(hh, data_length, padding);
}


static void prepare_matlab_header(int32_t **hh, size_t buf_size)
{
    char *mat_header = (char *) *hh;
    memset(mat_header, 0, buf_size);

    /* The first 128 bytes are the description and format marks. */
    memset(mat_header, ' ', 124);
    sprintf(mat_header, "MATLAB 5.0 MAT-file generated from FA sniffer data");
    mat_header[strlen(mat_header)] = ' ';
    *(uint16_t *)&mat_header[124] = 0x0100;   // Version flag
    *(uint16_t *)&mat_header[126] = 0x4d49;   // 'IM' endian mark
    *hh = (int32_t *)&mat_header[128];
}


bool write_matlab_header(
    int file_out, filter_mask_t filter_mask, unsigned int data_mask,
    uint32_t decimation, double timestamp, double frequency,
    unsigned int dump_length, const char *name, bool *squeeze)
{
    char mat_header[4096];
    int32_t *h = (int32_t *) mat_header;
    prepare_matlab_header(&h, sizeof(mat_header));

    /* Write out the decimation, sample frequency and timestamp. */
    write_matlab_value(&h, "decimation", miINT32, &decimation);
    write_matlab_value(&h, "f_s", miDOUBLE, &frequency);
    write_matlab_value(&h, "timestamp", miDOUBLE, &timestamp);

    /* Write out the index array tying data back to original BPM ids. */
    uint8_t mask_ids[FA_ENTRY_COUNT];
    int mask_length = compute_mask_ids(mask_ids, filter_mask);
    write_matlab_vector(&h, "ids", miUINT8, mask_ids, mask_length);

    /* Finally write out the matrix mat_header for the fa data. */
    int field_count = count_data_bits(data_mask);
    write_matrix_header(&h, name,
        miINT32, squeeze,
        FA_ENTRY_SIZE * field_count * mask_length * dump_length,
        4, 2, field_count, mask_length, dump_length);

    return TEST_write(file_out, mat_header, (char *) h - mat_header);
}


unsigned int count_data_bits(unsigned int mask)
{
    return
        ((mask >> 0) & 1) + ((mask >> 1) & 1) +
        ((mask >> 2) & 1) + ((mask >> 3) & 1);
}


double matlab_timestamp(uint64_t timestamp)
{
    return MATLAB_EPOCH + (1e-6 * timestamp) / SECS_PER_DAY;
}
