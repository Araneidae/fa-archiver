/* Support for writing a matlab header on capture FA data. */

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>

#include "sniffer.h"
#include "mask.h"
#include "error.h"

#include "matlab.h"


/* The delta (in days) between the Unix and matlab epochs, generated by running
 *  datenum(1970, 1, 1)
 * in matlab. */
#define MATLAB_EPOCH    719529
#define SECS_PER_DAY    (24 * 60 * 60)



#define miMATRIX        14

#define mxDOUBLE_CLASS  6
#define mxINT32_CLASS   12


/* Sizes of matlab formats, dynamically looked up. */
static struct { int format; size_t size; } format_sizes[] = {
    { miINT8,   sizeof(int8_t) },
    { miUINT8,  sizeof(uint8_t) },
    { miINT16,  sizeof(int16_t) },
    { miUINT16, sizeof(uint16_t) },
    { miINT32,  sizeof(int32_t) },
    { miUINT32, sizeof(uint32_t) },
    { miDOUBLE, sizeof(double) },
};

static size_t lookup_size(int format)
{
    for (size_t i = 0; i < ARRAY_SIZE(format_sizes); i ++)
        if (format_sizes[i].format == format)
            return format_sizes[i].size;
    ASSERT_OK(false);
}


int compute_mask_ids(uint8_t *array, filter_mask_t mask)
{
    int count = 0;
    for (int bit = 0; bit < 256; bit ++)
        if (test_mask_bit(mask, bit))
        {
            *array++ = bit;
            count += 1;
        }
    return count;
}


static void write_matlab_string(int32_t **hh, const char *string)
{
    int32_t *h = *hh;
    int l = strlen(string);
    *h++ = miINT8;      *h++ = l;
    memcpy(h, string, l);
    *hh = h + 2 * ((l + 7) / 8);
}


/* Returns the number of bytes of padding required after data_length bytes of
 * following data to ensure that the entire matrix is padded to 8 bytes. */
int place_matrix_header(
    int32_t **hh, const char *name, int data_type,
    bool *squeeze, int data_length, int dimensions, ...)
{
    va_list dims;
    va_start(dims, dimensions);

    int32_t *h = *hh;
    *h++ = miMATRIX;
    int32_t *l = h++;   // total length will be written here.
    // Matrix flags: consists of two uint32 words encoding the class.
    *h++ = miUINT32;    *h++ = 8;
    *h++ = mxDOUBLE_CLASS;
    *h++ = 0;

    // Matrix dimensions: one int32 for each dimension
    *h++ = miINT32;
    int32_t *dim_size = h++;    // Size of dimensions to be written here
    int squeezed_dims = 0;
    for (int i = 0; i < dimensions; i ++)
    {
        int size = va_arg(dims, int32_t);
        if (size == 1  &&  squeeze != NULL  &&  squeeze[i])
            /* Squeeze this dimension out by ignoring it altogether. */
            ;
        else
        {
            *h++ = size;
            squeezed_dims += 1;
        }
    }
    *dim_size = squeezed_dims * sizeof(int32_t);
    h += squeezed_dims & 1;    // Padding if required

    // Element name
    write_matlab_string(&h, name);

    // Data header: data follows directly after.
    int padding = (8 - data_length) & 7;
    *h++ = data_type;   *h++ = data_length;
    *l = data_length + (h - l - 1) * sizeof(int32_t) + padding;

    *hh = h;
    return padding;
}


/* Advances pointer by length together with the precomputed padding. */
static void pad(int32_t **hh, int length, int padding)
{
    *hh = (int32_t *)((char *)*hh + length + padding);
}


void place_matlab_value(
    int32_t **hh, const char *name, int data_type, void *data)
{
    size_t data_size = lookup_size(data_type);
    int padding = place_matrix_header(
        hh, name, data_type, NULL, data_size, 1, 1);
    memcpy(*hh, data, data_size);
    pad(hh, data_size, padding);
}


void place_matlab_vector(
    int32_t **hh, const char *name, int data_type,
    void *data, int vector_length)
{
    int data_length = lookup_size(data_type) * vector_length;
    int padding = place_matrix_header(
        hh, name, data_type, NULL, data_length, 2, 1, vector_length);
    memcpy(*hh, data, data_length);
    pad(hh, data_length, padding);
}


void prepare_matlab_header(int32_t **hh, size_t buf_size)
{
    char *mat_header = (char *) *hh;
    memset(mat_header, 0, buf_size);

    /* The first 128 bytes are the description and format marks. */
    memset(mat_header, ' ', 124);
    sprintf(mat_header, "MATLAB 5.0 MAT-file generated from FA sniffer data");
    mat_header[strlen(mat_header)] = ' ';
    *(uint16_t *)&mat_header[124] = 0x0100;   // Version flag
    *(uint16_t *)&mat_header[126] = 0x4d49;   // 'IM' endian mark
    *hh = (int32_t *)&mat_header[128];
}


unsigned int count_data_bits(unsigned int mask)
{
    return
        ((mask >> 0) & 1) + ((mask >> 1) & 1) +
        ((mask >> 2) & 1) + ((mask >> 3) & 1);
}


double matlab_timestamp(uint64_t timestamp)
{
    return MATLAB_EPOCH + (1e-6 * timestamp) / SECS_PER_DAY;
}
